/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package com.mycompany.thecccjavaedition;

import java.util.ArrayList;
import javax.swing.JRadioButton;

/**
 *
 * @author Rene Lorenzo Pitahin
 */

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.util.*;
public class CCCInterface extends javax.swing.JFrame {
    
    private Graph cityGraph;
    private DataManager dataManager;
    private final Random random = new Random();
    private int resolvedCases = 0;
    private int unsolvedCases = 0;

    
    /**
     * Creates new form CCCInterface
     */
    public CCCInterface() {
        initComponents();
        cityGraph = new Graph(); // Initialize cityGraph
        initializeGraph();       // Populate cityGraph with nodes and edges
        dataManager = new DataManager(cityGraph, this); // Pass both cityGraph and CCCInterface
        initializeTables();      // Populate tables
        startTimers();           // Start background updates
    }


    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        tblUnitsAndStatus = new javax.swing.JTable();
        jScrollPane2 = new javax.swing.JScrollPane();
        tblEmergencyIncidents = new javax.swing.JTable();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        btnDispatchUnit = new javax.swing.JButton();
        btnCancelDispatch = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();
        txtSolvedIncidents = new javax.swing.JTextField();
        txtUnsolvedIncidents = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("CCC Lucena Town Proper");

        tblUnitsAndStatus.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "No.", "Unit", "Location", "Status", "Travel Time"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane1.setViewportView(tblUnitsAndStatus);
        if (tblUnitsAndStatus.getColumnModel().getColumnCount() > 0) {
            tblUnitsAndStatus.getColumnModel().getColumn(0).setResizable(false);
            tblUnitsAndStatus.getColumnModel().getColumn(1).setResizable(false);
            tblUnitsAndStatus.getColumnModel().getColumn(2).setResizable(false);
            tblUnitsAndStatus.getColumnModel().getColumn(3).setResizable(false);
            tblUnitsAndStatus.getColumnModel().getColumn(4).setResizable(false);
        }

        tblEmergencyIncidents.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "No.", "Incident", "Node", "Requirement", "Demand", "Time left (s)"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.Object.class, java.lang.String.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane2.setViewportView(tblEmergencyIncidents);
        if (tblEmergencyIncidents.getColumnModel().getColumnCount() > 0) {
            tblEmergencyIncidents.getColumnModel().getColumn(0).setResizable(false);
            tblEmergencyIncidents.getColumnModel().getColumn(1).setResizable(false);
            tblEmergencyIncidents.getColumnModel().getColumn(2).setResizable(false);
            tblEmergencyIncidents.getColumnModel().getColumn(3).setResizable(false);
            tblEmergencyIncidents.getColumnModel().getColumn(4).setResizable(false);
            tblEmergencyIncidents.getColumnModel().getColumn(5).setResizable(false);
        }

        jLabel2.setFont(new java.awt.Font("Times New Roman", 0, 18)); // NOI18N
        jLabel2.setText("Incidents from Calls");

        jLabel3.setFont(new java.awt.Font("Times New Roman", 0, 18)); // NOI18N
        jLabel3.setText("Available Units");

        jLabel4.setFont(new java.awt.Font("Times New Roman", 1, 48)); // NOI18N
        jLabel4.setText("CCC");

        jLabel7.setFont(new java.awt.Font("STKaiti", 0, 18)); // NOI18N
        jLabel7.setText("Command & Control Center");

        btnDispatchUnit.setText("Call a Unit");
        btnDispatchUnit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDispatchUnitActionPerformed(evt);
            }
        });

        btnCancelDispatch.setText("Cancel Dispatch");
        btnCancelDispatch.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCancelDispatchActionPerformed(evt);
            }
        });

        jButton1.setText("Close program");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        txtSolvedIncidents.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        txtSolvedIncidents.setForeground(new java.awt.Color(0, 204, 0));
        txtSolvedIncidents.setText("0");

        txtUnsolvedIncidents.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        txtUnsolvedIncidents.setForeground(new java.awt.Color(255, 51, 51));
        txtUnsolvedIncidents.setText("0");

        jLabel5.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        jLabel5.setText("Unsolved Cases");

        jLabel6.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        jLabel6.setText("Solved Cases");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(166, 166, 166)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel2)
                .addGap(269, 269, 269))
            .addGroup(layout.createSequentialGroup()
                .addGap(24, 24, 24)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addGap(6, 6, 6)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel4)
                            .addComponent(jLabel7))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(btnDispatchUnit, javax.swing.GroupLayout.PREFERRED_SIZE, 145, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnCancelDispatch, javax.swing.GroupLayout.PREFERRED_SIZE, 141, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 142, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jLabel6)
                                .addGap(18, 18, 18)
                                .addComponent(txtSolvedIncidents, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jLabel5)
                                .addGap(18, 18, 18)
                                .addComponent(txtUnsolvedIncidents, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(152, 152, 152))))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 21, Short.MAX_VALUE)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 390, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 658, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(24, 24, 24))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(17, 17, 17)
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel7)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(jLabel2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 333, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(txtSolvedIncidents, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel6))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(txtUnsolvedIncidents, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel5)))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 333, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(btnDispatchUnit, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(btnCancelDispatch, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap(14, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void initializeGraph() {
        // Initialize one-way edges for vertical directions
        cityGraph.addEdge("V2", "S6", 1);
        cityGraph.addEdge("S6", "R6", 1);
        cityGraph.addEdge("R6", "Q7", 1);
        cityGraph.addEdge("Q7", "P7", 1);
        cityGraph.addEdge("P7", "O8", 1);
        cityGraph.addEdge("O8", "N8", 1);
        cityGraph.addEdge("N8", "M8", 1);
        cityGraph.addEdge("M8", "L8", 1);
        cityGraph.addEdge("L8", "K8", 1);
        cityGraph.addEdge("K8", "J7", 1);
        cityGraph.addEdge("J7", "I9", 1);
        cityGraph.addEdge("I9", "H7", 1);
        cityGraph.addEdge("H7", "G7", 1);
        cityGraph.addEdge("G7", "F7", 1);
        cityGraph.addEdge("F7", "E6", 1);
        cityGraph.addEdge("E6", "D6", 1);
        cityGraph.addEdge("D6", "C6", 1);
        cityGraph.addEdge("C6", "A3", 1);

        cityGraph.addEdge("V3", "S7", 1);
        cityGraph.addEdge("S7", "R7", 1);
        cityGraph.addEdge("R7", "Q8", 1);
        cityGraph.addEdge("Q8", "P8", 1);
        cityGraph.addEdge("P8", "O9", 1);
        cityGraph.addEdge("O9", "N9", 1);
        cityGraph.addEdge("N9", "M9", 1);
        cityGraph.addEdge("M9", "L9", 1);
        cityGraph.addEdge("L9", "K9", 1);
        cityGraph.addEdge("K9", "J8", 1);
        cityGraph.addEdge("J8", "I10", 1);
        cityGraph.addEdge("I10", "H8", 1);
        cityGraph.addEdge("H8", "G8", 1);
        cityGraph.addEdge("G8", "F8", 1);

        cityGraph.addEdge("B3", "C5", 1);
        cityGraph.addEdge("C5", "D5", 1);
        cityGraph.addEdge("D5", "E5", 1);

        cityGraph.addEdge("F5", "G5", 1);
        cityGraph.addEdge("G5", "H5", 1);
        cityGraph.addEdge("H5", "I7", 1);
        cityGraph.addEdge("I7", "J5", 1);
        cityGraph.addEdge("J5", "K6", 1);
        cityGraph.addEdge("K6", "L6", 1);
        cityGraph.addEdge("L6", "M6", 1);
        cityGraph.addEdge("M6", "N6", 1);
        cityGraph.addEdge("N6", "O6", 1);
        cityGraph.addEdge("O6", "P5", 1);
        cityGraph.addEdge("P5", "Q5", 1);
        cityGraph.addEdge("Q5", "R4", 1);
        cityGraph.addEdge("R4", "S4", 1);

        cityGraph.addEdge("S1", "R1", 1);
        cityGraph.addEdge("R1", "Q2", 1);
        cityGraph.addEdge("Q2", "P2", 1);
        cityGraph.addEdge("P2", "O3", 1);
        cityGraph.addEdge("O3", "N3", 1);
        cityGraph.addEdge("N3", "M3", 1);
        cityGraph.addEdge("M3", "L3", 1);
        cityGraph.addEdge("L3", "K3", 1);
        cityGraph.addEdge("K3", "I4", 1);
        cityGraph.addEdge("I4", "H2", 1);
        cityGraph.addEdge("H2", "G2", 1);
        cityGraph.addEdge("G2", "F2", 1);
        cityGraph.addEdge("F2", "E1", 1);

        cityGraph.addEdge("I3", "J3", 1);
        cityGraph.addEdge("J3", "K2", 1);
        cityGraph.addEdge("K2", "L2", 1);
        cityGraph.addEdge("L2", "M2", 1);
        cityGraph.addEdge("M2", "N2", 1);
        cityGraph.addEdge("N2", "O2", 1);

        cityGraph.addEdge("I2", "J2", 1);
        cityGraph.addEdge("J2", "K1", 1);
        cityGraph.addEdge("K1", "L1", 1);
        cityGraph.addEdge("L1", "M1", 1);
        cityGraph.addEdge("M1", "N1", 1);

        // Initialize one-way edges for horizontal directions
        cityGraph.addEdge("B2", "B3", 1);

        cityGraph.addEdge("C6", "C5", 1);
        cityGraph.addEdge("C5", "C4", 1);
        cityGraph.addEdge("C4", "C3", 1);

        cityGraph.addEdge("E6", "E5", 1);
        cityGraph.addEdge("E5", "E4", 1);
        cityGraph.addEdge("E4", "E3", 1);
        cityGraph.addEdge("E3", "E2", 1);
        cityGraph.addEdge("E2", "E1", 1);

        cityGraph.addEdge("G1", "G2", 1);
        cityGraph.addEdge("G2", "G3", 1);
        cityGraph.addEdge("G3", "G4", 1);
        cityGraph.addEdge("G4", "G5", 1);
        cityGraph.addEdge("G5", "G6", 1);
        cityGraph.addEdge("G6", "G7", 1);
        cityGraph.addEdge("G7", "G8", 1);

        cityGraph.addEdge("H8", "H7", 1);
        cityGraph.addEdge("H7", "H6", 1);
        cityGraph.addEdge("H6", "H5", 1);
        cityGraph.addEdge("H5", "H4", 1);
        cityGraph.addEdge("H4", "H3", 1);
        cityGraph.addEdge("H3", "H2", 1);
        cityGraph.addEdge("H2", "H1", 1);

        cityGraph.addEdge("I10", "I9", 1);
        cityGraph.addEdge("I9", "I8", 1);
        cityGraph.addEdge("I8", "I7", 1);
        cityGraph.addEdge("I7", "I6", 1);
        cityGraph.addEdge("I6", "I5", 1);
        cityGraph.addEdge("I5", "I4", 1);
        cityGraph.addEdge("I4", "I3", 1);

        cityGraph.addEdge("J2", "J1", 1);
        cityGraph.addEdge("J1", "I3", 1);

        cityGraph.addEdge("K3", "K4", 1);
        cityGraph.addEdge("K4", "K5", 1);
        cityGraph.addEdge("K5", "K6", 1);
        cityGraph.addEdge("K6", "K7", 1);
        cityGraph.addEdge("K7", "K8", 1);
        cityGraph.addEdge("K8", "K9", 1);

        cityGraph.addEdge("L9", "L8", 1);
        cityGraph.addEdge("L8", "L7", 1);
        cityGraph.addEdge("L7", "L6", 1);
        cityGraph.addEdge("L6", "L5", 1);
        cityGraph.addEdge("L5", "L4", 1);
        cityGraph.addEdge("L4", "L3", 1);
        cityGraph.addEdge("L3", "L2", 1);
        cityGraph.addEdge("L2", "L1", 1);

        cityGraph.addEdge("N1", "N2", 1);
        cityGraph.addEdge("N2", "N3", 1);
        cityGraph.addEdge("N3", "N4", 1);
        cityGraph.addEdge("N4", "N5", 1);
        cityGraph.addEdge("N5", "N6", 1);
        cityGraph.addEdge("N6", "N7", 1);
        cityGraph.addEdge("N7", "N8", 1);
        cityGraph.addEdge("N8", "N9", 1);

        cityGraph.addEdge("O8", "O7", 1);
        cityGraph.addEdge("O7", "O6", 1);
        cityGraph.addEdge("O6", "O5", 1);
        cityGraph.addEdge("O5", "O4", 1);
        cityGraph.addEdge("O4", "O3", 1);

        cityGraph.addEdge("P8", "P7", 1);
        cityGraph.addEdge("P7", "P6", 1);
        cityGraph.addEdge("P6", "P5", 1);
        cityGraph.addEdge("P5", "P4", 1);
        cityGraph.addEdge("P4", "P3", 1);
        cityGraph.addEdge("P3", "P2", 1);

        cityGraph.addEdge("Q1", "Q2", 1);
        cityGraph.addEdge("Q2", "Q3", 1);
        cityGraph.addEdge("Q3", "Q4", 1);
        cityGraph.addEdge("Q4", "Q5", 1);
        cityGraph.addEdge("Q5", "Q6", 1);
        cityGraph.addEdge("Q6", "Q7", 1);
        cityGraph.addEdge("Q7", "Q8", 1);

        cityGraph.addEdge("R7", "R6", 1);
        cityGraph.addEdge("R6", "R5", 1);
        cityGraph.addEdge("R5", "R4", 1);
        cityGraph.addEdge("R4", "R3", 1);
        cityGraph.addEdge("R3", "R2", 1);
        cityGraph.addEdge("R2", "R1", 1);

        cityGraph.addEdge("U2", "U3", 1);

        cityGraph.addEdge("V1", "V2", 1);

        // two-way traffic routes
        
        // Two-way vertical routes
        addTwoWayEdge("A2", "B2", 1);
        addTwoWayEdge("B2", "C4", 1);
        addTwoWayEdge("C4", "D4", 1);
        addTwoWayEdge("D4", "E4", 1);
        addTwoWayEdge("E4", "F5", 1);

        addTwoWayEdge("B1", "C3", 1);
        addTwoWayEdge("C3", "D3", 1);
        addTwoWayEdge("D3", "E3", 1);
        addTwoWayEdge("E3", "F4", 1);
        addTwoWayEdge("F4", "G4", 1);
        addTwoWayEdge("G4", "H4", 1);
        addTwoWayEdge("H4", "I6", 1);

        addTwoWayEdge("C2", "D2", 1);
        addTwoWayEdge("D2", "E2", 1);
        addTwoWayEdge("E2", "F3", 1);
        addTwoWayEdge("F3", "G3", 1);
        addTwoWayEdge("G3", "H3", 1);
        addTwoWayEdge("H3", "I5", 1);

        addTwoWayEdge("C1", "D1", 1);
        addTwoWayEdge("D1", "E1", 1);

        addTwoWayEdge("F1", "G1", 1);
        addTwoWayEdge("G1", "H1", 1);
        addTwoWayEdge("H1", "I3", 1);

        addTwoWayEdge("F6", "G6", 1);
        addTwoWayEdge("G6", "H6", 1);
        addTwoWayEdge("H6", "I8", 1);
        addTwoWayEdge("I8", "J6", 1);
        addTwoWayEdge("J6", "K7", 1);
        addTwoWayEdge("K7", "L7", 1);
        addTwoWayEdge("L7", "M7", 1);
        addTwoWayEdge("M7", "N7", 1);
        addTwoWayEdge("N7", "O7", 1);
        addTwoWayEdge("O7", "P6", 1);
        addTwoWayEdge("P6", "Q6", 1);
        addTwoWayEdge("Q6", "R5", 1);
        addTwoWayEdge("R5", "S5", 1);

        addTwoWayEdge("N1", "O1", 1);

        addTwoWayEdge("K4", "L4", 1);
        addTwoWayEdge("L4", "M4", 1);
        addTwoWayEdge("M4", "N4", 1);
        addTwoWayEdge("N4", "O4", 1);
        addTwoWayEdge("O4", "P3", 1);
        addTwoWayEdge("P3", "Q3", 1);
        addTwoWayEdge("Q3", "R2", 1);
        addTwoWayEdge("R2", "S2", 1);
        addTwoWayEdge("S2", "T2", 1);
        addTwoWayEdge("T2", "U1", 1);

        addTwoWayEdge("S1", "T1", 1);

        addTwoWayEdge("O2", "P1", 1);
        addTwoWayEdge("P1", "Q1", 1);

        addTwoWayEdge("S4", "T4", 1);
        addTwoWayEdge("T4", "U3", 1);
        addTwoWayEdge("U3", "V1", 1);
        addTwoWayEdge("V1", "W1", 1);

        addTwoWayEdge("Q8", "S8", 1);
        addTwoWayEdge("S8", "V4", 1);

        // Two-way horizontal routes
        addTwoWayEdge("A1", "A2", 1);
        addTwoWayEdge("A2", "A3", 1);

        addTwoWayEdge("B1", "B2", 1);

        addTwoWayEdge("C1", "C2", 1);
        addTwoWayEdge("C2", "C3", 1);

        addTwoWayEdge("D1", "D2", 1);
        addTwoWayEdge("D2", "D3", 1);
        addTwoWayEdge("D3", "D4", 1);
        addTwoWayEdge("D4", "D5", 1);
        addTwoWayEdge("D5", "D6", 1);

        addTwoWayEdge("F1", "F2", 1);
        addTwoWayEdge("F2", "F3", 1);
        addTwoWayEdge("F3", "F4", 1);
        addTwoWayEdge("F4", "F5", 1);
        addTwoWayEdge("F5", "F6", 1);
        addTwoWayEdge("F6", "F7", 1);
        addTwoWayEdge("F7", "F8", 1);

        addTwoWayEdge("I1", "I2", 1);
        addTwoWayEdge("I2", "I3", 1);

        addTwoWayEdge("J2", "J3", 1);

        addTwoWayEdge("J4", "J5", 1);
        addTwoWayEdge("J5", "J6", 1);
        addTwoWayEdge("J6", "J7", 1);
        addTwoWayEdge("J7", "J8", 1);

        addTwoWayEdge("K1", "K2", 1);
        addTwoWayEdge("K2", "K3", 1);

        addTwoWayEdge("M1", "M2", 1);
        addTwoWayEdge("M2", "M3", 1);
        addTwoWayEdge("M3", "M4", 1);
        addTwoWayEdge("M4", "M5", 1);
        addTwoWayEdge("M5", "M6", 1);
        addTwoWayEdge("M6", "M7", 1);
        addTwoWayEdge("M7", "M8", 1);
        addTwoWayEdge("M8", "M9", 1);

        addTwoWayEdge("O1", "O2", 1);
        addTwoWayEdge("O2", "O3", 1);

        addTwoWayEdge("P1", "P2", 1);

        addTwoWayEdge("Q1", "Q2", 1);
        addTwoWayEdge("Q2", "Q3", 1);
        addTwoWayEdge("Q3", "Q4", 1);
        addTwoWayEdge("Q4", "Q5", 1);
        addTwoWayEdge("Q5", "Q6", 1);
        addTwoWayEdge("Q6", "Q7", 1);
        addTwoWayEdge("Q7", "Q8", 1);

        addTwoWayEdge("R7", "R8", 1);

        addTwoWayEdge("S1", "S2", 1);
        addTwoWayEdge("S2", "S3", 1);
        addTwoWayEdge("S3", "S4", 1);
        addTwoWayEdge("S4", "S5", 1);
        addTwoWayEdge("S5", "S6", 1);
        addTwoWayEdge("S6", "S7", 1);
        addTwoWayEdge("S7", "S8", 1);

        addTwoWayEdge("T1", "T2", 1);
        addTwoWayEdge("T2", "T3", 1);
        addTwoWayEdge("T3", "T4", 1);

        addTwoWayEdge("U1", "U2", 1);

        addTwoWayEdge("V2", "V3", 1);
        addTwoWayEdge("V3", "V4", 1);

        addTwoWayEdge("W1", "W2", 1);
    }

    
    
    // Helper method to add two-way edges
    private void addTwoWayEdge(String from, String to, int weight) {
        cityGraph.addEdge(from, to, weight);
        cityGraph.addEdge(to, from, weight);
    }
        
       

    
    private void initializeTables() {
        DefaultTableModel unitModel = (DefaultTableModel) tblUnitsAndStatus.getModel();
        for (Unit unit : dataManager.getUnits()) {
            unitModel.addRow(new Object[]{unit.getUnitNumber(), unit.getType(), "Available", "0"});
        }

        generateRandomIncident();
    }
    
    private void btnDispatchUnitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDispatchUnitActionPerformed
        // Retrieve available units
        String[] units = dataManager.getAvailableUnits();
        if (units.length == 0) {
            JOptionPane.showMessageDialog(this, "No available units for dispatch.");
            return;
        }

        // Show unit selection dialog
        String selectedUnit = (String) JOptionPane.showInputDialog(
                this,
                "Select a unit:",
                "Dispatch Unit",
                JOptionPane.QUESTION_MESSAGE,
                null,
                units,
                units[0]
        );

        if (selectedUnit != null) {
            // Retrieve unresolved incidents with incident numbers
            String[] incidents = dataManager.getIncidents().stream()
                    .filter(i -> !i.isAssigned()) // Only show unassigned incidents
                    .map(i -> i.getIncidentNumber() + " - " + i.getType() + " (" + i.getNode() + ")")
                    .toArray(String[]::new);

            if (incidents.length == 0) {
                JOptionPane.showMessageDialog(this, "No unresolved incidents to dispatch.");
                return;
            }

            // Show incident selection dialog
            String selectedIncident = (String) JOptionPane.showInputDialog(
                    this,
                    "Select an incident:",
                    "Dispatch Unit",
                    JOptionPane.QUESTION_MESSAGE,
                    null,
                    incidents,
                    incidents[0]
            );

            if (selectedIncident != null) {
                // Extract selected unit number and incident number
                String unitNumber = selectedUnit.split(" - ")[0]; // Extract unit number
                int incidentNumber = Integer.parseInt(selectedIncident.split(" - ")[0]); // Extract incident number

                // Find the matching incident
                Incident matchingIncident = dataManager.getIncidents().stream()
                        .filter(i -> i.getIncidentNumber() == incidentNumber)
                        .findFirst()
                        .orElse(null);

                if (matchingIncident != null) {
                    // Calculate the shortest path
                    Unit unit = dataManager.getUnitByNumber(unitNumber);
                    List<String> path = Dijkstra.shortestPath(cityGraph, unit.getLocation(), matchingIncident.getNode());

                    if (path.isEmpty()) {
                        JOptionPane.showMessageDialog(this, "No valid path found to the incident.");
                        return;
                    }

                    // Display the path as a message
                    String pathMessage = "Unit " + unitNumber + " will travel through the following nodes:\n" + String.join(" -> ", path);
                    JOptionPane.showMessageDialog(this, pathMessage, "Unit Dispatch Path", JOptionPane.INFORMATION_MESSAGE);

                    // Dispatch the unit and simulate movement
                    simulateUnitMovement(unit, path, matchingIncident);
                } else {
                    JOptionPane.showMessageDialog(this, "No matching incident found.");
                }
            }
        }
    }//GEN-LAST:event_btnDispatchUnitActionPerformed

    private void btnCancelDispatchActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCancelDispatchActionPerformed
        // Get units that are currently dispatched (not available or returning to base)
        String[] units = dataManager.getUnits().stream()
                .filter(unit -> !unit.isAvailable())
                .map(unit -> unit.getUnitNumber() + " - " + unit.getType())
                .toArray(String[]::new);

        if (units.length == 0) {
            JOptionPane.showMessageDialog(this, "No dispatched units to cancel.");
            return;
        }

        // Display a dialog to select the unit to cancel
        String selectedUnit = (String) JOptionPane.showInputDialog(
                this,
                "Select a unit to cancel dispatch:",
                "Cancel Dispatch",
                JOptionPane.QUESTION_MESSAGE,
                null,
                units,
                units[0]
        );

        if (selectedUnit != null) {
            String unitNumber = selectedUnit.split(" - ")[0];

            // Fetch the unit and cancel the dispatch
            Unit unit = dataManager.getUnitByNumber(unitNumber);
            if (unit != null) {
                // If a unit is assigned to an incident, detach it
                Incident incident = dataManager.getIncidents().stream()
                        .filter(i -> unit.getUnitNumber().equals(i.getAssignedUnit()))
                        .findFirst()
                        .orElse(null);

                if (incident != null) {
                    // Unassign the unit from the incident
                    incident.setAssigned(false);
                    incident.setAssignedUnit(null);
                    refreshIncidentTable(); // Refresh incident table
                }

                // Return the unit to base
                unit.setReturningToBase(true);
                returnUnitToBase(unit); // Simulate the movement back to the base
                JOptionPane.showMessageDialog(this, "Dispatch for Unit " + unitNumber + " has been canceled. The unit is returning to base.");
            } else {
                JOptionPane.showMessageDialog(this, "No matching unit found.");
            }
        }
    }//GEN-LAST:event_btnCancelDispatchActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        int response = JOptionPane.showConfirmDialog(
            this, 
            "Are you sure you want to exit the program?", 
            "Confirm Exit", 
            JOptionPane.YES_NO_OPTION, 
            JOptionPane.QUESTION_MESSAGE
        );

        if (response == JOptionPane.YES_OPTION) {
            dispose();
        } else {
            JOptionPane.showMessageDialog(this, "Canceled", "Action Canceled", JOptionPane.INFORMATION_MESSAGE);
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    private void startTimers() {
    // Random incident generation every 5 seconds
        new javax.swing.Timer(5000, e -> {
            generateRandomIncident();
            refreshIncidentTable();
        }).start();

        // Update units and incidents every second
        new javax.swing.Timer(1000, e -> {
            dataManager.updateUnitsAndIncidents(); // Update travel times and statuses
            refreshUnitTable(); // Refresh unit UI table to reflect changes
            refreshIncidentTable(); // Refresh incident UI table if needed
        }).start();
    }
    
    private void generateRandomIncident() {
    // Adjust the probability of incident generation (e.g., 20% chance to generate an incident)
        if (random.nextInt(100) < 99) { //chance to generate an incident
            String[] policeIncidents = {"Videoke", "Shoplifting", "Murder", "Homicide", "Burglar", "Car Accident", "Bank Robbery", "Drugs"};
            String[] ambulanceIncidents = {"Burns", "Accident", "Injury", "Unconscious", "Nahulog Sakanya", "Dead body", "Seizure", "Fall"};
            String[] fireIncidents = {"Fire", "Fallen Tree", "Flood", "Electrical", "Transformer Failure", "Fire Alarm", "Chemicals"};

            String requirement;
            String type;
            String demand;
            int timeLeft;

            int category = random.nextInt(3);
            if (category == 0) { // Police
                requirement = "Police";
                type = policeIncidents[random.nextInt(policeIncidents.length)];
            } else if (category == 1) { // Ambulance
                requirement = "Ambulance";
                type = ambulanceIncidents[random.nextInt(ambulanceIncidents.length)];
            } else { // Fire
                requirement = "Fire";
                type = fireIncidents[random.nextInt(fireIncidents.length)];
            }

            // Randomly set demand and timeLeft based on demand level
            int demandLevel = random.nextInt(3); // 0 = Low, 1 = Moderate, 2 = Severe
            if (demandLevel == 0) {
                demand = "Low";
                timeLeft = 600; // 10 minutes
            } else if (demandLevel == 1) {
                demand = "Moderate";
                timeLeft = 300; // 5 minutes
            } else {
                demand = "Severe";
                timeLeft = 60; // 1 minute
            }

            dataManager.addIncident(type, requirement, demand, timeLeft);
        }
    }

    public void refreshUnitTable() {
        DefaultTableModel model = (DefaultTableModel) tblUnitsAndStatus.getModel();
        model.setRowCount(0);

        for (Unit unit : dataManager.getUnits()) {
            model.addRow(new Object[]{
                unit.getUnitNumber(),
                unit.getType(),
                unit.getLocation(),
                unit.isAvailable() ? "Available" : (unit.isReturningToBase() ? "Returning to Base" : "Busy"),
                unit.getTravelTime() > 0 ? unit.getTravelTime() + "s" : "0s"
            });
        }
    }

    public void refreshIncidentTable() {
        DefaultTableModel model = (DefaultTableModel) tblEmergencyIncidents.getModel();
        model.setRowCount(0);

        for (Incident incident : dataManager.getIncidents()) {
            String timeDisplay = incident.isAssigned() && incident.getSolvingTime() > 0
                    ? "Solving: " + incident.getSolvingTime() + "s"
                    : "Time Left: " + incident.getTimeLeft() + "s";
            model.addRow(new Object[]{
                incident.getIncidentNumber(),
                incident.getType(),
                incident.getNode(),
                incident.getRequirement(),
                incident.getDemand(),
                timeDisplay
            });
        }
    }

    public void simulateUnitMovement(Unit unit, List<String> path, Incident incident) {
        unit.setAvailable(false); // Mark the unit as unavailable
        unit.setTravelTime(path.size() * 2); // Calculate and set travel time
        refreshUnitTable(); // Refresh UI to reflect updated state

        javax.swing.Timer movementTimer = new javax.swing.Timer(1000, null);
        final Iterator<String> pathIterator = path.iterator();

        movementTimer.addActionListener(e -> {
            if (pathIterator.hasNext() && unit.getTravelTime() > 0) {
                String nextNode = pathIterator.next();
                unit.setLocation(nextNode); // Update the unit's location
                unit.setTravelTime(unit.getTravelTime() - 1); // Decrement travel time
                refreshUnitTable(); // Update UI
            } else {
                movementTimer.stop();
                unit.setTravelTime(0); // Ensure travel time hits 0 upon arrival
                refreshUnitTable();

                if (incident != null) {
                    // Reset the incident's time to 60 seconds
                    incident.setTimeLeft(60);
                    startIncidentSolvingTimer(unit, incident); // Start the solving process
                } else {
                    // Handle base return or generic completion
                    unit.setAvailable(true);
                    unit.setReturningToBase(false);
                    refreshUnitTable();
                }
            }
        });

        movementTimer.start();
    }

    public void startIncidentSolvingTimer(Unit unit, Incident incident) {
        incident.setDemand("Solving"); // Update the status of the incident to "Solving"
        incident.setSolvingTime(60); // Set solving time to 60 seconds
        refreshIncidentTable(); // Refresh the UI to show updated incident details

        javax.swing.Timer solvingTimer = new javax.swing.Timer(1000, null);

        solvingTimer.addActionListener(e -> {
            if (incident.getSolvingTime() > 0) {
                incident.decrementSolvingTime(); // Decrement the solving time
                refreshIncidentTable(); // Update UI
            } else {
                solvingTimer.stop(); // Stop the timer upon completion
                // Mark the incident as resolved
                dataManager.markIncidentAsResolved(incident);
                refreshIncidentTable();

                // Initiate unit return to base
                unit.setReturningToBase(true);
                returnUnitToBase(unit);
            }
        });

        solvingTimer.start();
    }


    private int calculateReturnTravelTime(Unit unit, Incident incident) {
        List<String> returnPath = Dijkstra.shortestPath(cityGraph, incident.getNode(), unit.getBaseLocation());
        return returnPath.size() * 2; // Example: 2 seconds per node
    }
    
    private void returnUnitToBase(Unit unit) {
    // Get the shortest path from the current location to the base
        List<String> returnPath = Dijkstra.shortestPath(cityGraph, unit.getLocation(), unit.getBaseLocation());

        // Simulate the movement along the path
        javax.swing.Timer returnTimer = new javax.swing.Timer(1000, null);
        final Iterator<String> pathIterator = returnPath.iterator();

        returnTimer.addActionListener(e -> {
            if (pathIterator.hasNext()) {
                String nextNode = pathIterator.next();
                unit.setLocation(nextNode); // Update unit location
                refreshUnitTable(); // Update UI
            } else {
                returnTimer.stop(); // Stop the timer upon arrival
                unit.setReturningToBase(false);
                unit.setAvailable(true); // Mark the unit as available
                refreshUnitTable();
            }
        });

        returnTimer.start();
    }


    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(CCCInterface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(CCCInterface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(CCCInterface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(CCCInterface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new CCCInterface().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnCancelDispatch;
    private javax.swing.JButton btnDispatchUnit;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTable tblEmergencyIncidents;
    private javax.swing.JTable tblUnitsAndStatus;
    private javax.swing.JTextField txtSolvedIncidents;
    private javax.swing.JTextField txtUnsolvedIncidents;
    // End of variables declaration//GEN-END:variables
}
